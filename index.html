<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C++ Code Blocks Collection</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <h1>C++ Code Blocks Collection</h1>
    
    <!-- Codeblock-1: Fractional Knapsack -->
    <div class="code-block">
      <h2>Codeblock-1: Fractional Knapsack</h2>
      <pre><code id="code-fractional-knapsack">
#include&lt;bits/stdc++.h&gt;
using namespace std;

bool compare(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {
    double r1 = (double)a.first / a.second;
    double r2 = (double)b.first / b.second;
    return r1 &gt; r2;
}

double fractionalKnapsack(int W, vector&lt;pair&lt;int, int&gt;&gt;&amp; arr) {
    sort(arr.begin(), arr.end(), compare);
    double totalValue = 0.0;
    
    for (int i = 0; i &lt; arr.size(); i++) {
        if (W &gt;= arr[i].second) {
            totalValue += arr[i].first;
            W -= arr[i].second;
        } else {
            totalValue += arr[i].first * ((double)W / arr[i].second);
            break;
        }
    }
    return totalValue;
}

int main(){
    cout &lt;&lt; "Enter number of items:" &lt;&lt; endl;
    int n;
    cin &gt;&gt; n; 
    vector&lt;pair&lt;int, int&gt;&gt; arr(n);
    cout &lt;&lt; "Enter value and weight of items:" &lt;&lt; endl;
    for(int i = 0; i &lt; n; i++){
        cin &gt;&gt; arr[i].first >> arr[i].second;
    }
    cout &lt;&lt; "Enter maximum weight of bag:" &lt;&lt; endl;
    int W;
    cin &gt;&gt; W;
    cout &lt;&lt; "Maximum value: " &lt;&lt; fractionalKnapsack(W, arr) &lt;&lt; endl;
    return 0;
}
      </code></pre>
      <button id="copy-btn" data-code="code-fractional-knapsack">Copy Code</button>
    </div>

    <!-- Codeblock-2: Huffman -->
    <div class="code-block">
      <h2>Codeblock-2: Huffman</h2>
      <pre><code id="code-huffman">
#include&lt;bits/stdc++.h&gt;
using namespace std;

struct Node {
    char data;
    int freq;
    Node *left, *right;
    Node(char d, int f) : data(d), freq(f), left(nullptr), right(nullptr) {}
};

struct compare {
    bool operator()(Node* l, Node* r) {
        return l-&gt;freq &gt; r-&gt;freq;
    }
};

void printCodes(Node* root, string str) {
    if (!root) return;
    if (root-&gt;data != '$')
        cout &lt;&lt; root-&gt;data &lt;&lt; ": " &lt;&lt; str &lt;&lt; "\n";
    printCodes(root-&gt;left, str + "0");
    printCodes(root-&gt;right, str + "1");
}

void huffmanCode(vector&lt;char&gt;&amp; data, vector&lt;int&gt;&amp; freq) {
    priority_queue&lt;Node*, vector&lt;Node*&gt;, compare&gt; pq;
    for (int i = 0; i &lt; data.size(); i++)
        pq.push(new Node(data[i], freq[i]));
    
    while (pq.size() &gt; 1) {
        Node *left = pq.top(); pq.pop();
        Node *right = pq.top(); pq.pop();
        Node *top = new Node('$', left-&gt;freq + right-&gt;freq);
        top-&gt;left = left;
        top-&gt;right = right;
        pq.push(top);
    }
    printCodes(pq.top(), "");
}

int main(){
    int n;
    cin &gt;&gt; n;
    vector&lt;char&gt; data(n);
    for(int i = 0; i &lt; n; i++){
        cin &gt;&gt; data[i];
    }
    vector&lt;int&gt; freq(n);
    for(int i = 0; i &lt; n; i++){
        cin &gt;&gt; freq[i];
    }
    huffmanCode(data, freq);
    return 0;
}
      </code></pre>
      <button id="copy-btn" data-code="code-huffman">Copy Code</button>
    </div>

    <!-- Codeblock-3: Job Scheduling -->
    <div class="code-block">
      <h2>Codeblock-3: Job Scheduling</h2>
      <pre><code id="code-job-scheduling">
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Job {
    char id;
    int deadline, profit;
};

bool comparison(Job a, Job b) {
    return (a.profit &gt; b.profit);
}

void jobScheduling(vector&lt;Job&gt;&amp; arr, int n) {
    sort(arr.begin(), arr.end(), comparison);
    int maxDeadline = 0;
    for (int i = 0; i &lt; n; i++)
        maxDeadline = max(maxDeadline, arr[i].deadline);
    
    vector&lt;char&gt; result(maxDeadline, ' ');
    int totalProfit = 0;
    
    for (int i = 0; i &lt; n; i++) {
        for (int j = min(maxDeadline, arr[i].deadline) - 1; j &gt;= 0; j--) {
            if (result[j] == ' ') {
                result[j] = arr[i].id;
                totalProfit += arr[i].profit;
                break;
            }
        }
    }
    
    cout &lt;&lt; "Scheduled Jobs: ";
    for (char c : result) if (c != ' ') cout &lt;&lt; c &lt;&lt; " ";
    cout &lt;&lt; "\nTotal Profit: " &lt;&lt; totalProfit &lt;&lt; endl;
}

int main() {
    vector&lt;Job&gt; arr = {{'p', 3, 80}, {'q', 2, 30}, {'r', 1, 45},
                           {'s', 2, 60}, {'t', 1, 20}};
    jobScheduling(arr, arr.size());
    return 0;
}
      </code></pre>
      <button id="copy-btn" data-code="code-job-scheduling">Copy Code</button>
    </div>
    
    <!-- Codeblock-4: Knapsack_dp -->
    <div class="code-block">
      <h2>Codeblock-4: Knapsack DP</h2>
      <pre><code id="code-knapsack">
#include "bits/stdc++.h"
#define Code ios::sync_with_stdio(false);
#define By cin.tie(0);
#define Nishit cout.tie(0);
using ll = long long;
#define int ll
#define endl '\n'
const int mod = 1000000007;
using namespace std;

int knapsack(int W, vector&lt;int&gt;&amp; wt, vector&lt;int&gt;&amp; val, int n) {
    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(W + 1, 0));
    
    for (int i = 1; i &lt;= n; i++) {
        for (int w = 0; w &lt;= W; w++) {
            if (wt[i-1] &lt;= w)
                dp[i][w] = max(val[i-1] + dp[i-1][w-wt[i-1]], dp[i-1][w]);
            else
                dp[i][w] = dp[i-1][w];
        }
    }
    return dp[n][W];
}

void solve()
{
    int n;
    cin &gt;&gt; n; 
    vector&lt;int&gt; val(n);
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; val[i];
    vector&lt;int&gt; wt(n);
    for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; wt[i];
    int W;
    cin &gt;&gt; W;
    cout &lt;&lt; "Maximum value: " &lt;&lt; knapsack(W, wt, val, n) &lt;&lt; endl;    
}

int32_t main()
{
    Code By Nishit
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
      </code></pre>
      <button id="copy-btn" data-code="code-knapsack">Copy Code</button>
    </div>
    
    <!-- Codeblock-5: LCS_dp -->
    <div class="code-block">
      <h2>Codeblock-5: LCS DP</h2>
      <pre><code id="code-lcs">
#include "bits/stdc++.h"
#define Code ios::sync_with_stdio(false);
#define By cin.tie(0);
#define Nishit cout.tie(0);
using ll = long long;
#define int ll
#define endl '\n'
const int mod = 1000000007;
using namespace std;

int lcs(string X, string Y) {
    int m = X.length(), n = Y.length();
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
    
    for (int i = 1; i &lt;= m; i++) {
        for (int j = 1; j &lt;= n; j++) {
            if (X[i-1] == Y[j-1])
                dp[i][j] = dp[i-1][j-1] + 1;
            else
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        }
    }
    return dp[m][n];
}

void solve()
{
    string X;
    cin &gt;&gt; X;
    string Y;
    cin &gt;&gt; Y;
    cout &lt;&lt; "Length of LCS: " &lt;&lt; lcs(X, Y) &lt;&lt; endl; 
    cout &lt;&lt; "---------------------------------------------------" &lt;&lt; endl;   
}

int32_t main()
{
    Code By Nishit
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
      </code></pre>
      <button id="copy-btn" data-code="code-lcs">Copy Code</button>
    </div>
    
    <!-- Codeblock-6: Prim's Algorithm -->
    <div class="code-block">
      <h2>Codeblock-6: Prim's Algorithm (MST)</h2>
      <pre><code id="code-prims">
#include &lt;bits/stdc++.h&gt;
using namespace std;
// Prim's Algorithm for Minimum Spanning Tree (MST)
int spanningTree(int V, vector&lt;vector&lt;int&gt;&gt; adj[])
{
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;
    vector&lt;int&gt; vis(V, 0);
    pq.push({0, 0});
    int sum = 0;
    while (!pq.empty())
    {
        auto it = pq.top();
        pq.pop();
        int node = it.second;
        int wt = it.first;
        if (vis[node] == 1)
            continue;
        vis[node] = 1;
        sum += wt;
        for (auto it : adj[node])
        {
            int adjNode = it[0];
            int edW = it[1];
            if (!vis[adjNode])
            {
                pq.push({edW, adjNode});
            }
        }
    }
    return sum;
}

int main()
{
    int V = 5;
    vector&lt;vector&lt;int&gt;&gt; edges = {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};
    vector&lt;vector&lt;int&gt;&gt; adj[V];
    for (auto it : edges)
    {
        vector&lt;int&gt; tmp(2);
        tmp[0] = it[1];
        tmp[1] = it[2];
        adj[it[0]].push_back(tmp);
        tmp[0] = it[0];
        tmp[1] = it[2];
        adj[it[1]].push_back(tmp);
    }
    int sum = spanningTree(V, adj);
    cout &lt;&lt; "The sum of all the edge weights: " &lt;&lt; sum &lt;&lt; endl;
    return 0;
}
      </code></pre>
      <button id="copy-btn" data-code="code-prims">Copy Code</button>
    </div>
    
    <!-- Codeblock-7: Kruskal's Algorithm -->
    <div class="code-block">
      <h2>Codeblock-7: Kruskal's Algorithm</h2>
      <pre><code id="code-kruskal">
#include &lt;bits/stdc++.h&gt;
using namespace std;

class DisjointSet {
    vector&lt;int&gt; rank, parent, size;
public:
    DisjointSet(int n) {
        rank.resize(n + 1, 0);
        parent.resize(n + 1);
        size.resize(n + 1);
        for (int i = 0; i &lt;= n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    int findUPar(int node) {
        if (node == parent[node])
            return node;
        return parent[node] = findUPar(parent[node]);
    }

    void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank[ulp_u] &lt; rank[ulp_v])
            parent[ulp_u] = ulp_v;
        else if (rank[ulp_v] &lt; rank[ulp_u])
            parent[ulp_v] = ulp_u;
        else {
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }

    void unionBySize(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (size[ulp_u] &lt; size[ulp_v]) {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        } else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};

class Solution {
public:
    int spanningTree(int V, vector&lt;vector&lt;int&gt;&gt; adj[])
    {
        vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; edges;
        for (int i = 0; i &lt; V; i++) {
            for (auto it : adj[i]) {
                int adjNode = it[0];
                int wt = it[1];
                int node = i;
                edges.push_back({wt, {node, adjNode}});
            }
        }
        DisjointSet ds(V);
        sort(edges.begin(), edges.end());
        int mstWt = 0;
        for (auto it : edges) {
            int wt = it.first;
            int u = it.second.first;
            int v = it.second.second;
            if (ds.findUPar(u) != ds.findUPar(v)) {
                mstWt += wt;
                ds.unionBySize(u, v);
            }
        }
        return mstWt;
    }
};

int main() {
    int V = 5;
    vector&lt;vector&lt;int&gt;&gt; edges = {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};
    vector&lt;vector&lt;int&gt;&gt; adj[V];
    for (auto it : edges) {
        vector&lt;int&gt; tmp(2);
        tmp[0] = it[1];
        tmp[1] = it[2];
        adj[it[0]].push_back(tmp);
        tmp[0] = it[0];
        tmp[1] = it[2];
        adj[it[1]].push_back(tmp);
    }
    Solution obj;
    int mstWt = obj.spanningTree(V, adj);
    cout &lt;&lt; "The sum of all the edge weights: " &lt;&lt; mstWt &lt;&lt; endl;
    return 0;
}
      </code></pre>
      <button id="copy-btn" data-code="code-kruskal">Copy Code</button>
    </div>

    <!-- Codeblock-8: Median Finding -->
<div class="code-block">
    <h2>Codeblock-8: Median Finding</h2>
    <pre><code id="code-median">
  #include &lt;bits/stdc++.h&gt;
  using namespace std;
  
  int findMedian(vector&lt;int&gt;&amp; arr) {
      sort(arr.begin(), arr.end());
      return arr[arr.size() / 2];
  }
  
  int rankOfElement(int r, vector&lt;int&gt;&amp; A) {
      int n = A.size();
      
      if (n == 1) {
          return A[0];
      }
      
      int numGroups = (n + 4) / 5;
      vector&lt;int&gt; B;
      
      for (int i = 0; i &lt; n; i += 5) {
          int end = min(i + 5, n);
          vector&lt;int&gt; temp(A.begin() + i, A.begin() + end);
          B.push_back(findMedian(temp));
      }
      
      int Xmed = rankOfElement(numGroups / 2, B);
      
      vector&lt;int&gt; left, right;
      int countXmed = 0;
      
      for (int num : A) {
          if (num &lt; Xmed) {
              left.push_back(num);
          } else if (num &gt; Xmed) {
              right.push_back(num);
          } else {
              countXmed++;
          }
      }
      
      if (left.size() == r - 1) {
          return Xmed;
      }
      
      if (left.size() &gt; r - 1) {
          return rankOfElement(r, left);
      }
      
      return rankOfElement(r - left.size() - countXmed, right);
  }
  
  int main() {
      vector&lt;int&gt; A = {12, 3, 5, 7, 19, 26, 45, 17, 1, 2, 8, 4, 6, 10};
      int r = 11;
      cout << "The element at rank " << r << " is " << rankOfElement(r, A) << endl;
      return 0;
  }
    </code></pre>
    <button id="copy-btn" data-code="code-median">Copy Code</button>
  </div>
  
  <!-- Codeblock-9: Closest Pair -->
  <div class="code-block">
    <h2>Codeblock-9: Closest Pair</h2>
    <pre><code id="code-closest-pair">
  #include &lt;bits/stdc++.h&gt;
  using namespace std;
  
  struct Coordinate {
      double x, y;
  };
  
  double computeSeparation(Coordinate p1, Coordinate p2) {
      return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
  }
  
  bool arrangeByX(Coordinate a, Coordinate b) { return a.x &lt; b.x; }
  bool arrangeByY(Coordinate a, Coordinate b) { return a.y &lt; b.y; }
  
  double bruteForceMinDist(vector&lt;Coordinate&gt;&amp; coords, int begin, int finish) {
      double smallestGap = numeric_limits&lt;double&gt;::max();
      
      for (int i = begin; i &lt; finish; i++) {
          for (int j = i + 1; j &lt;= finish; j++) {
              double currentGap = computeSeparation(coords[i], coords[j]);
              smallestGap = min(smallestGap, currentGap);
          }
      }
      
      return smallestGap;
  }
  
  double stripClosestPair(vector&lt;Coordinate&gt;&amp; section, double minGap) {
      double result = minGap;
      
      sort(section.begin(), section.end(), arrangeByY);
      
      for (int i = 0; i &lt; section.size(); i++) {
          for (int j = i + 1; j &lt; section.size() &amp;&amp; (section[j].y - section[i].y) &lt; result; j++) {
              result = min(result, computeSeparation(section[i], section[j]));
          }
      }
      
      return result;
  }
  
  double recursiveClosestPair(vector&lt;Coordinate&gt;&amp; coords, int begin, int finish) {
      if (finish - begin &lt;= 3) {
          return bruteForceMinDist(coords, begin, finish);
      }
      
      int midpoint = (begin + finish) / 2;
      Coordinate midCoord = coords[midpoint];
      
      double leftGap = recursiveClosestPair(coords, begin, midpoint);
      double rightGap = recursiveClosestPair(coords, midpoint + 1, finish);
      double minGap = min(leftGap, rightGap);
      
      vector&lt;Coordinate&gt; section;
      for (int i = begin; i &lt;= finish; i++) {
          if (abs(coords[i].x - midCoord.x) &lt; minGap) {
              section.push_back(coords[i]);
          }
      }
      
      return min(minGap, stripClosestPair(section, minGap));
  }
  
  double closestPairDistance(vector&lt;Coordinate&gt;&amp; coords) {
      sort(coords.begin(), coords.end(), arrangeByX);
      return recursiveClosestPair(coords, 0, coords.size() - 1);
  }
  
  int main() {
      vector&lt;Coordinate&gt; samplePoints = {
          {2, 3}, {12, 30}, {40, 50}, 
          {5, 1}, {12, 10}, {3, 4}
      };
      
      cout << "Closest pair distance: " << closestPairDistance(samplePoints) << endl;
      return 0;
  }
    </code></pre>
    <button id="copy-btn" data-code="code-closest-pair">Copy Code</button>
  </div>
  
  <!-- Codeblock-10: Convex Hull -->
  <div class="code-block">
    <h2>Codeblock-10: Convex Hull</h2>
    <pre><code id="code-convexhull">
  #include &lt;bits/stdc++.h&gt;
  using namespace std;
  
  struct Coordinate {
      int x, y;
  };
  
  // Determine orientation of three points (clockwise, counterclockwise, collinear)
  int computeOrientation(Coordinate c1, Coordinate c2, Coordinate c3) {
      int crossProd = (c2.y - c1.y) * (c3.x - c2.x) - (c2.x - c1.x) * (c3.y - c2.y);
      
      if (crossProd == 0) return 0;  // Collinear
      return (crossProd &gt; 0) ? 1 : 2; // Clockwise (1) or Counterclockwise (2)
  }
  
  Coordinate referencePoint;
  
  bool sortByPolarAngle(Coordinate a, Coordinate b) {
      int orient = computeOrientation(referencePoint, a, b);
      
      if (orient == 0) {
          return (a.x - referencePoint.x) * (a.x - referencePoint.x) + 
                 (a.y - referencePoint.y) * (a.y - referencePoint.y) &lt; 
                 (b.x - referencePoint.x) * (b.x - referencePoint.x) + 
                 (b.y - referencePoint.y) * (b.y - referencePoint.y);
      }
      
      return orient == 2; 
  }
  
  vector&lt;Coordinate&gt; generateConvexHull(vector&lt;Coordinate&gt;&amp; coords) {
      int numPoints = coords.size();
      
      if (numPoints &lt; 3) return {};
  
      int lowestIndex = 0;
      int minY = coords[0].y;
      
      for (int i = 1; i &lt; numPoints; i++) {
          int y = coords[i].y;
          
          if (y &lt; minY || (y == minY && coords[i].x &lt; coords[lowestIndex].x)) {
              minY = y;
              lowestIndex = i;
          }
      }
      
      swap(coords[0], coords[lowestIndex]);
      referencePoint = coords[0];
      
      sort(coords.begin() + 1, coords.end(), sortByPolarAngle);
      
      vector&lt;Coordinate&gt; hull;
      hull.push_back(coords[0]);
      hull.push_back(coords[1]);
      
      for (int i = 2; i &lt; numPoints; i++) {
          while (hull.size() &gt; 1 && 
                 computeOrientation(hull[hull.size() - 2], hull[hull.size() - 1], coords[i]) != 2) {
              hull.pop_back();
          }
          
          hull.push_back(coords[i]);
      }
      
      return hull;
  }
  
  int main() {
      vector&lt;Coordinate&gt; samplePoints = {
          {0, 3}, {2, 2}, {1, 1}, {2, 1}, 
          {3, 0}, {0, 0}, {3, 3}
      };
      
      vector&lt;Coordinate&gt; hull = generateConvexHull(samplePoints);
      
      cout << "Convex Hull points:\n";
      for (auto coord : hull) {
          cout << "(" << coord.x << ", " << coord.y << ")\n";
      }
      
      return 0;
  }
    </code></pre>
    <button id="copy-btn" data-code="code-convexhull">Copy Code</button>
  </div>
  

    
  </div>
  
  <script src="script.js"></script>


    
</body>
</html>
